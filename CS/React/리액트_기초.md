> 목차
> React란 무엇인가?
> 컴포넌트 기반 개발의 이해
> JSX 문법 살펴보기
> Props와 State의 역할
> 이벤트 핸들링
> 조건부 렌더링과 리스트 렌더링

## 1. React란 무엇인가?

| React란 UI를 구축하는데 사용되는 js 라이브러리 입니다!

### 그러면 프레임워크와 라이브러리의 차이를 아시나요?

- 라이브러리는 필요한 도구를 담아놓은 도구상자!
- 프레임워크는 이미 뼈대가 완성된 집 짓기 세트와 비슷합니다,
  집의 크기는 이미 정해져 있고, 개발자는 그 안에 벽을 세우고 가구를 배치하는 것처럼 정해진 규칙에 따라 코드를 작성하는 방식이죠

> 두 개념의 가장 큰 차이점은 **코드 흐름의 주도권 차이** 입니다

- 라이브러리는 개발자가 코드를 주도하고 필요할때 라이브러리나 함수를 호출해서 사용하는 방식입니다.
- 반면에 프레임워크는 미리 정해놓은 틀 안에 개발자가 코드를 끼워 넣는 방식이에요.
  - 이렇게 프로그램의 제어권이 거꾸로 되는 것을 제어의 역전(IoC) 이라고 합니다

## 2. 컴포넌트 기반 개발이란?

> 컴포넌트 기반 개발이란 웹페이지를 각각의 기능 별로 나누어서 독립적이고 재사용 가능하게 분리시켜 개발하는 방식을 말합니다

react는 상태가 변경되면 리렌더링 하는 방식으로 동작하는데 페이지가 커다란 덩어리라면 항상 모든것을 리렌더링 해야해요

하지만 페이지를 여러개의 컴포넌트로 나누면 어떨까요?

해당 컴포넌트만 리렌더링하면 되겠죠?
이러한 방식을 가능하게 해주는 중요한 개념이 Virtual DOM입니다

## 3. Virtual DOM

> Virtual DOM은 React의 핵심 동작 원리 중 하나이자, 컴포넌트 기반 개발 방식의 효율성을 극대화 시켜주는 중요한 개념입니다!

### 가상돔과 실제 돔의 차이점

- 실제 DOM = 건축가들이 실제 사용하는 정식 설계도라고 할수 있어요. 건물의 모든 구조와 재료에 대한 정보가 들어있고 수정시 많은 시간과 노력이 필요해요
- 가삼 DOM = 건축가들이 실제 설계도를 수정하기 전에 만드는 초안 설계도와 같아요, 실제 건물과 똑같은 구조를 스케치하는거죠

### 그렇다면 실제 DOM은 왜 수정하는게 오래걸릴까요?

- DOM(Document Object Model)은 웹페이지의 모든 요소를 하나의 거대한 객체 트리 구조로 표현한 거에요.
- 그런데 이 실제 DOM은 굉장히 무거운 구조이고 실제 브라우저에 존재하며 브라우저 렌더링 엔진이 직접 처리하는 무겁고 복잡한 객체들의 집합이에요
- 반면 가상 DOM은 React가 메모리에 만들어 놓은, 가벼운 js 객체 트리에요
- 이때 실제 DOM을 수정 하는 과정이 느린 가장 큰 이유는 reflow , repaint 과정이 매우 복잡하고 비용이 많이 들기 때문이에요

그렇기 때문에 가상 dom을 먼저 조작한 후 실제 dom에 적용해 불필요한 렌더링을 줄여 성능을 최적화 할 수 있습니다

Virtual DOM의 형태 예시

```html
변환되기 전 코드

<div className="container">
  <h1>Hello, React!</h1>
  <p>이것은 가상 DOM 예시입니다.</p>
</div>
```

```javascript
Virtual DOM으로 변환된 모습
{
  type: 'div',
  props: { className: 'container' },
  children: [
    {
      type: 'h1',
      props: {},
      children: 'Hello, React!'
    },
    {
      type: 'p',
      props: {},
      children: '이것은 가상 DOM 예시입니다.'
    }
  ]
}
```

### Reflow와 Repaint란?

1. Reflow란?

   - 건축 설계도를 다시그리는것
   - 웹페이지의 요소의 크기, 위치, 폰트같이 레이아웃에 영향을 주는 속성이 바뀌면, 브라우저는 모든 요소의 크기와 위치를 다시 계산해야 해요

2. Repaint란?
   - 페인트를 다시 칠하는것
   - 레이아웃에는 영향이 없고 색상, 투명도 같은 시각적 스타일만 바뀌었을때 해당 요소의 픽셀을 다시 그리는 과정이에요

- 이때 Reflow가 Repaint를 항상 포함하기 때문에 Reflow가 일어난다면 Repaint도 무조건 함께 일어나요

### Virtual DOM은 어떤 방식으로 바뀐 객체를 인식할까?(Diffing 알고리즘)

> 상태가 업데이트 될 때 마다 두 개의 가상 DOM 트리를 비교하는 알고리즘! Diffing 알고리즘을 이용해 비교합니다

그럼 Diffing 알고리즘은 어떤식으로 작동할까요?

- 단순히 모든 객체를 하나씩 비교하는 것이 아닌 react가 정해놓은 몇가지 휴리스틱(Heuristic, 발견법)을 사용해 효율적으로 비교합니다

1. 다른타입의 엘리먼트일 경우

   - 만약 이전 가상 DOM의 루트 노드 타입이 다르면, React는 이전 트리를 완전히 버리고 새로운 트리를 처음부터 다시 만들어요

   - 예를 들어, `<div>`엘리먼트가 `<p>`엘리먼트로 바뀌면, React는 내부 모든 자식 엘리먼트들을 비교하지 않고 통째로 버립니다.

2. 동일한 타입의 엘리먼트일 경우
   - 만약 이전 가상 DOM과 새로운 가상 DOM의 루트 노드 타입이 같다면, React는 두 엘리먼트의 속성만 비교해요
   - 예를 들어, `<div className="old">`가 `<div className="new">`로 바뀌었다면, className 속성만 변경된 것으로 판단하고 해당 부분만 수정하죠

### 객체를 인식 한 후 적용은 어떤 방식으로 할까?(Reconciliation)

> Reconciliation 과정은 두 단계 Render Phase와 CommitPhase로 나눌 수 있습니다.

1. Render Phase
   - diffing 알고리즘을 통해 이전과 새로운 가상 DOM 트리를 비교, 파악 후 effect list(변경 목록)에 담습니다
   - 이 단계에서는 실제 DOM에 아무런 영향도 주지 않아요
2. Commit Phase:
   - Render Phase에서 만ㄷ르어진 effect list를 바탕으로, 실제 DOM에 한꺼번에 변경 사항을 적용합니다
   - 이때 비로소 화면에 보이는 UI가 실제로 업데이트 됩니다.

### key prop가 중요한 이유

> key prop을 사용하면 diffing 알고리즘의 효율성을 높여줄 수 있습니다!

1. key prop이 없다면 react는 리스트의 어떤 항목이 변경,추가, 삭제되었는지 정확하게 파악이 어렵지만 key를 통해 고유하게 식별할 수 있기 때문에 정확히 판단할 수 있어요

### viewport가 변경되는 상황은 어떨까?

virtual DOM은 state의 변화에 따라 dom을 효율적으로 업데이트하기 위한 것이기 때문에 상관없는 개념이다.

그러므로 창 크기를 줄였을 때 레이아웃이 변경되거나 reflow를 해야하는 상황 또는 repaint를 해야하는 상황이 왔을 경우에만 reflow, repaint 됩니다.
